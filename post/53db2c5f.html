<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Kubernetes RUSH | Rayce. Blogs</title><meta name="author" content="Rayce."><meta name="copyright" content="Rayce."><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基本概述Kubernetes是容器集群管理系统（简单来说就是一个开源的、用于管理云平台中多个主机的容器化应用），是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。(docker compose管理的是单机的， 并不是容器化的) K8S的目标是： 让部署容器化的应用简单并且高效。k8s提供了应用部署、规划、更新、维护的一种机制。 几种不同时代的部署方式![image.png]&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes RUSH">
<meta property="og:url" content="https://ray2310.github.io/post/53db2c5f.html">
<meta property="og:site_name" content="Rayce. Blogs">
<meta property="og:description" content="基本概述Kubernetes是容器集群管理系统（简单来说就是一个开源的、用于管理云平台中多个主机的容器化应用），是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。(docker compose管理的是单机的， 并不是容器化的) K8S的目标是： 让部署容器化的应用简单并且高效。k8s提供了应用部署、规划、更新、维护的一种机制。 几种不同时代的部署方式![image.png]&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/01/wallhaven-01jvd3.jpg">
<meta property="article:published_time" content="2024-03-22T08:04:04.000Z">
<meta property="article:modified_time" content="2024-03-22T08:10:24.175Z">
<meta property="article:author" content="Rayce.">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/01/wallhaven-01jvd3.jpg"><link rel="shortcut icon" href="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQQHlJW3iX0eSx0YEsPnrToEC7iKW4m3TEgiQ&usqp=CAU"><link rel="canonical" href="https://ray2310.github.io/post/53db2c5f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Rayce.","link":"链接: ","source":"来源: Rayce. Blogs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes RUSH',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-22 16:10:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/109897266?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/01/wallhaven-01jvd3.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Rayce. Blogs"><span class="site-name">Rayce. Blogs</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kubernetes RUSH</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-22T08:04:04.000Z" title="发表于 2024-03-22 16:04:04">2024-03-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-22T08:10:24.175Z" title="更新于 2024-03-22 16:10:24">2024-03-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BF%90%E7%BB%B4/kubernetes/">kubernetes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kubernetes RUSH"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><p><strong>Kubernetes是容器集群管理系统（简单来说就是一个开源的、用于管理云平台中多个主机的容器化应用），是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。</strong><br><strong>(<strong>docker compose管理的是单机的， 并不是容器化的</strong>)</strong></p>
<p><strong>K8S的目标是： 让部署容器化的应用简单并且高效。k8s提供了应用部署、规划、更新、维护的一种机制。</strong></p>
<p>几种不同时代的部署方式<br>![image.png]&#x2F;images&#x2F;1710744258125-9bc0cf2f-ac2b-4da2-b0b1-1b63a0816fc4.png)</p>
<blockquote>
<ol>
<li>传统的部署方式是直接部署在操作系统上， 就像我们现在开发阶段一样， 直接将项目在操作系统上进行运行。 （但是<strong>存在的问题就是环境不隔离</strong>， 导致多个应用同时使用系统中的共享资源而发生的冲突问题。）</li>
</ol>
</blockquote>
<ol start="2">
<li>接着就进入了虚拟化的部署方式， 虚拟化技术允许你在单个物理服务器的 CPU 上运行多台<strong>虚拟机（VM）</strong>。 虚拟化能使应用程序<strong>在不同 VM 之间被彼此隔离</strong>，且能提供一定程度的安全性， 因为一个应用程序的信息不能被另一应用程序随意访问。</li>
</ol>
<p><strong>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。这样会出现占用资源过多的问题</strong></p>
<ol start="3">
<li>最后就是我们现在比较主流的使用容器化部署的方式， <strong>这种方式和虚拟化方式有着异曲同工之妙。 但是更宽松的隔离特性，使容器之间可以共享操作系统（OS）</strong></li>
</ol>
<blockquote>
<p>容器能够实现文件系统、网络、内存空间等公共资源的隔离。<br>因为容器本身就是基于操作系统的来实现的。他是和我们当前服务器也就是宿主机共用同一个操作系统资源的。所以他占用资源更少。</p>
</blockquote>
<p>且与 VM 类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。</p>
<h3 id="容器那么好，-为什么还要用k8s？"><a href="#容器那么好，-为什么还要用k8s？" class="headerlink" title="容器那么好， 为什么还要用k8s？"></a>容器那么好， 为什么还要用k8s？</h3><p>为什么这三种方式中， 容器化部署会逐渐的流行起来呢？ 原因就是因为他有着很多的优点： </p>
<ul>
<li><strong>敏捷应用程序的创建和部署：</strong>与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li>
<li><strong>持续开发、集成和部署</strong>：通过快速简单的回滚（由于镜像不可变性）， 提供可靠且频繁的容器镜像构建和部署。</li>
<li><strong>关注开发与运维的分离</strong>：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。</li>
<li><strong>可观察性</strong>：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li>
<li><strong>跨开发、测试和生产的环境一致性</strong>：在笔记本计算机上也可以和在云中运行一样的应用程序。</li>
<li><strong>跨云和操作系统发行版本的可移植性</strong>：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。</li>
<li><strong>以应用程序为中心的管理</strong>：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li>
<li><strong>松散耦合、分布式、弹性、解放的微服务</strong>：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li>
<li>资<strong>源隔离</strong>：可预测的应用程序性能。</li>
<li><strong>资源利用</strong>：高效率和高密度。</li>
</ul>
<h2 id="为什么需要Kubernetes，-它能够做什么-？"><a href="#为什么需要Kubernetes，-它能够做什么-？" class="headerlink" title="为什么需要Kubernetes， 它能够做什么 ？"></a>为什么需要Kubernetes， 它能够做什么 ？</h2><p>首先， 我们知道，** 容器是我们打包部署和运行应用程序的最好方式。** 在生产环境中， 你需要管理运行着应用程序的容器，并确保服务不会下线。 例如，如果一个容器发生故障，则你需要启动另一个容器。 如果此行为交由给系统处理，是不是会更容易一些？<br><strong>这就是 Kubernetes 要来做的事情！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移你的应用、提供部署模式等。</strong></p>
<h3 id="K8S能够提供的功能"><a href="#K8S能够提供的功能" class="headerlink" title="K8S能够提供的功能"></a>K8S能够提供的功能</h3><ul>
<li><strong>服务发现和负载均衡</strong></li>
</ul>
<p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址来暴露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p>
<ul>
<li><strong>存储编排</strong></li>
</ul>
<blockquote>
<p>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p>
</blockquote>
<ul>
<li><strong>自动部署和回滚</strong></li>
</ul>
<blockquote>
<p>你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p>
</blockquote>
<ul>
<li><strong>自动完成装箱计算你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。</strong></li>
</ul>
<blockquote>
<p>** **你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。</p>
</blockquote>
<ul>
<li><strong>自我修复</strong></li>
</ul>
<blockquote>
<p>Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。</p>
</blockquote>
<ul>
<li><strong>密钥与配置管理</strong></li>
</ul>
<blockquote>
<p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p>
</blockquote>
<ul>
<li><strong>批处理执行</strong></li>
</ul>
<blockquote>
<p>除了服务外，Kubernetes 还可以管理你的批处理和 CI（持续集成）工作负载，如有需要，可以替换失败的容器。</p>
</blockquote>
<ul>
<li><strong>水平扩缩</strong></li>
</ul>
<blockquote>
<p> 使用简单的命令、用户界面或根据 CPU 使用率自动对你的应用进行扩缩。</p>
</blockquote>
<ul>
<li><strong>IPv4&#x2F;IPv6 双栈</strong></li>
</ul>
<blockquote>
<p> 为 Pod（容器组）和 Service（服务）分配 IPv4 和 IPv6 地址。</p>
</blockquote>
<ul>
<li><strong>为可扩展性设计</strong></li>
</ul>
<blockquote>
<p>在不改变上游源代码的情况下为你的 Kubernetes 集群添加功能。</p>
</blockquote>
<h3 id="K8s不是什么-？"><a href="#K8s不是什么-？" class="headerlink" title="K8s不是什么 ？"></a>K8s不是什么 ？</h3><p><strong>Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。</strong> 由于 Kubernetes 是在容器级别运行，而非在硬件级别，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡，允许用户集成他们的日志记录、监控和警报方案。 但是，<strong>Kubernetes 不是单体式（monolithic）系统</strong>，那些默认解决方案都是可选、可插拔的。 Kubernetes 为构建开发人员平台提供了基础，但是在重要的地方保留了用户选择权，能有更高的灵活性。</p>
<h2 id="操作K8s-—-K8s对象"><a href="#操作K8s-—-K8s对象" class="headerlink" title="操作K8s —- K8s对象"></a>操作K8s —- K8s对象</h2><p>![image.png]&#x2F;images&#x2F;1710746096577-d35d50bc-86e2-4042-a879-d733cd8de1c7.png)</p>
<blockquote>
<p>我们这里只是了解了最基本的，剩下的内容暂时没有学习到。 </p>
</blockquote>
<p>**操作 Kubernetes 对象 —— 无论是创建、修改或者删除 —— 需要使用 **<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api"><strong>Kubernetes API</strong></a><strong>。 比如，当使用 kubectl 命令行接口（CLI）时，CLI 会调用必要的 Kubernetes API； 也可以在程序中使用</strong><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries/"><strong>客户端库</strong></a><strong>， 来直接调用 Kubernetes API。</strong><br>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 <strong>spec（规约）</strong> 和对象 <strong>status（状态）</strong>。 对于具有 spec 的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： <strong>期望状态（Desired State）</strong>。</p>
<h3 id="描述-Kubernetes-对象"><a href="#描述-Kubernetes-对象" class="headerlink" title="描述 Kubernetes 对象"></a>描述 Kubernetes 对象</h3><p><strong>创建 Kubernetes 对象时，必须提供对象的 spec，用来描述该对象的期望状态</strong>， 以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（直接创建或经由 kubectl 创建），** API 请求必须在请求主体中包含 JSON 格式的信息。** 大多数情况下，你会通过 <strong>清单（Manifest)</strong> 文件为 kubectl 提供这些信息。 按照惯例，清单是 YAML 格式的（你也可以使用 JSON 格式）。 像 kubectl 这样的工具在通过 HTTP 进行 API 请求时， 会将清单中的信息转换为 JSON 或其他受支持的序列化格式。<br>这里有一个清单示例文件，展示了 Kubernetes Deployment 的必需字段和对象 spec：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 告知 Deployment 运行 2 个与该模板匹配的 Pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong>与上面使用清单文件来创建 Deployment 类似，另一种方式是使用 kubectl 命令行接口（CLI）的 <strong><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply"><strong>kubectl apply</strong></a></strong> 命令， 将 .yaml 文件作为参数</strong>。下面是一个示例：<br><code>kubectl apply -f https://k8s.io/examples/application/deployment.yaml</code><br>输出类似下面这样：<br><code>deployment.apps/nginx-deployment created</code></p>
<h3 id="必需字段"><a href="#必需字段" class="headerlink" title="必需字段"></a>必需字段</h3><p>在想要创建的 Kubernetes 对象所对应的清单（YAML 或 JSON 文件）中，需要配置的字段如下：</p>
<ul>
<li><strong>apiVersion - 创建该对象所使用的 Kubernetes API 的版本</strong></li>
<li><strong>kind - 想要创建的对象的类别</strong></li>
<li><strong>metadata - 帮助唯一标识对象的一些数据，包括一个 name 字符串、UID 和可选的 namespace</strong></li>
<li><strong>spec - 你所期望的该对象的状态</strong></li>
</ul>
<p>对每个 Kubernetes 对象而言，其 spec 之精确格式都是不同的，包含了特定于该对象的嵌套字段。 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/">Kubernetes API 参考</a>可以帮助你找到想要使用 Kubernetes 创建的所有对象的规约格式。</p>
<h2 id="Pod是什么？"><a href="#Pod是什么？" class="headerlink" title="Pod是什么？"></a>Pod是什么？</h2><p><strong>Kubernetes 中的 Pod 是 Kubernetes 集群中最小的、可以创建和管理的部署单元。每个 Pod 都包含一个或多个容器（例如 Docker 容器），这些容器共享存储、网络和一个运行规范。Pod 里的容器总是被同时调度到同一台主机上，并且在同一命名空间中运行，这意味着它们可以很容易地共享资源。</strong><br>Pod 是 Kubernetes 应用程序的基本构建块，每个 Pod 都被设计为运行一个特定的实例的应用程序。如果应用程序需要水平扩展，则可以通过增加 Pod 的副本数量来实现。</p>
<h3 id="主要特性："><a href="#主要特性：" class="headerlink" title="主要特性："></a>主要特性：</h3><ul>
<li><strong>共享网络：</strong>Pod 中的所有容器共享一个 IP 地址和端口空间，它们可以使用 localhost 相互通信。</li>
<li><strong>共享存储：</strong>Pod 可以定义共享存储卷，这些存储卷可以被 Pod 中的所有容器访问。</li>
<li><strong>生命周期管理：</strong>Kubernetes 以 Pod 为单位管理容器的生命周期。Pod 中的容器会同时被创建和销毁。</li>
<li><strong>资源共享和通信：</strong>由于 Pod 中的容器共享相同的网络命名空间，它们可以使用标准的进程间通信（IPC）和同一主机上的其他进程通信，如通过共享内存。</li>
<li><strong>独立管理：</strong>虽然一个 Pod 可以包含多个容器，但它们作为一个整体被 Kubernetes 管理，这简化了部署和管理过程。</li>
</ul>
<p>在设计应用时，通常会将相互密切相关且需要紧密协作的容器放在同一个 Pod 中。例如，一个应用程序容器和一个辅助的日志收集容器可以被部署在同一个 Pod 中。这种设计模式有助于简化相关容器间的通信和资源共享。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>每个运行的容器都是可重复的； 包含依赖环境在内的标准，意味着无论你在哪里运行它都会得到相同的行为。<br>容器<strong>将应用程序从底层的主机设施中解耦。</strong> <strong>这使得在不同的云或 OS 环境中部署更加容易。</strong><br>Kubernetes 集群中的每个<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a>都会运行容器， 这些容器构成分配给该节点的 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a>。 单个 Pod 中的容器会在共同调度下，于同一位置运行在相同的节点上。</p>
<h3 id="容器镜像"><a href="#容器镜像" class="headerlink" title="容器镜像"></a>容器镜像</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/containers/images/"><strong>容器镜像</strong></a><strong>是一个随时可以运行的软件包， 包含运行应用程序所需的一切</strong>：代码和它需要的所有运行时、应用程序和系统库，以及一些基本设置的默认值。<br>容器旨在设计成无状态且<a target="_blank" rel="noopener" href="https://glossary.cncf.io/immutable-infrastructure/">不可变的</a>： 你不应更改已经运行的容器的代码。如果有一个容器化的应用程序需要修改， 正确的流程是：先构建包含更改的新镜像，再基于新构建的镜像重新运行容器。</p>
<h3 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a>容器运行时</h3><p>这个基础组件使 Kubernetes 能够有效运行容器。 它负责管理 Kubernetes 环境中容器的执行和生命周期。<br>Kubernetes 支持许多容器运行环境，例如 <a target="_blank" rel="noopener" href="https://containerd.io/docs/">containerd</a>、 <a target="_blank" rel="noopener" href="https://cri-o.io/#what-is-cri-o">CRI-O</a> 以及 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">Kubernetes CRI (容器运行环境接口)</a> 的其他任何实现。<br>通常，你可以允许集群为一个 Pod 选择其默认的容器运行时。如果你需要在集群中使用多个容器运行时， 你可以为一个 Pod 指定 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/">RuntimeClass</a>， 以确保 Kubernetes 会使用特定的容器运行时来运行这些容器。</p>
<h1 id="K8s组件"><a href="#K8s组件" class="headerlink" title="K8s组件"></a>K8s组件</h1><p>当你部署完 Kubernetes，便拥有了一个完整的集群。<br>主节点可以即作为主节点 也 可以作为从节点<br><strong>一组工作机器，称为</strong><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/"><strong>节点</strong></a><strong>， 会运行容器化应用程序。每个集群至少有一个工作节点。</strong></p>
<blockquote>
<p><strong>Pod</strong> 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。<br><strong>Pod</strong>（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers">容器</a>；</p>
</blockquote>
<p>**工作节点会托管 **<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/"><strong>Pod</strong></a><strong>，而 Pod 就是作为应用负载的组件。</strong> <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>管理集群中的工作节点和 Pod。 在生产环境中，控制平面通常跨多台计算机运行， 一个集群通常运行多个节点，提供容错性和高可用性。</p>
<blockquote>
<p>本段概括了一个正常的k8s集群所需要的各种组件</p>
</blockquote>
<p>![image.png]&#x2F;images&#x2F;1711084841976-c6b81509-7142-4ecd-b65b-6e9f496675e5.png)</p>
<h2 id="控制平面组件（Control-Plame控制面板）—-在master上"><a href="#控制平面组件（Control-Plame控制面板）—-在master上" class="headerlink" title="控制平面组件（Control Plame控制面板）—-在master上"></a>控制平面组件（Control Plame控制面板）—-在master上</h2><p>![image.png]&#x2F;images&#x2F;1711087871903-813f6130-5389-4413-a94a-f0d97b044314.png)<br><strong>控制平面组件会为集群做出全局决策，比如资源的调度。</strong> 以及检测和响应集群事件，例如当不满足部署的 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-replica">replicas</a> 字段时，要启动新的 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a>)。<br><strong>控制平面组件可以在集群中的任何节点上运行。</strong> 然而，<strong>为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</strong></p>
<blockquote>
<p>控制平面组件有：<br>kube-apiserver  、kube-scheduler、 etcd、kube-controller-manager …</p>
</blockquote>
<h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><p>API 服务器是 Kubernetes <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。<br>Kubernetes API 服务器的主要实现是 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>。 kube-apiserver 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。</p>
<p><strong>接口服务，基于REST风格开发k8s接口的服务</strong><br><strong>的</strong></p>
<h3 id="kube-x2F-cloud-controller-manager"><a href="#kube-x2F-cloud-controller-manager" class="headerlink" title="kube&#x2F;cloud-controller-manager"></a>kube&#x2F;cloud-controller-manager</h3><p><strong>控制器管理器： 管理各个类型的控制器。 对k8s中的各种资源进行管理</strong><br><strong>从逻辑上讲，每个控制器都是一个单独的进程，但是为了降低复杂性，他们都被编译到同一个可执行文件，并在同一个进程中运行。</strong><br>我们上述中讲述了两个控制器管理器， 但是对于我们项目而言， cloud-controller-manager是第三方平台提供的控制器API对接管理功能。主要使用的是kube-controller-manager<br>这些控制器主要包括以下几种。</p>
<h4 id="控制器包括：-节点控制器"><a href="#控制器包括：-节点控制器" class="headerlink" title="控制器包括： 节点控制器"></a>控制器包括： 节点控制器</h4><p>节点控制器负责在云基础设施中创建了新服务器时为之更新<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（Node）</a>对象。** 节点控制器从云提供商获取当前租户中主机的信息。**节点控制器执行以下功能：</p>
<ol>
<li>使用从云平台 API 获取的对应服务器的唯一标识符更新 Node 对象；</li>
<li>利用特定云平台的信息为 Node 对象添加注解和标签，例如节点所在的区域 （Region）和所具有的资源（CPU、内存等等）；</li>
<li>获取节点的网络地址和主机名；</li>
<li>检查节点的健康状况。如果节点无响应，控制器通过云平台 API 查看该节点是否已从云中禁用、删除或终止。如果节点已从云中删除， 则控制器从 Kubernetes 集群中删除 Node 对象。</li>
</ol>
<p>某些云驱动实现中，这些任务被划分到一个节点控制器和一个节点生命周期控制器中。</p>
<h4 id="路由控制器"><a href="#路由控制器" class="headerlink" title="路由控制器"></a>路由控制器</h4><p>Route 控制器负责适当地配置云平台中的路由，以便 Kubernetes 集群中不同节点上的容器之间可以相互通信。<br>取决于云驱动本身，路由控制器可能也会为 Pod 网络分配 IP 地址块。</p>
<h4 id="服务控制器"><a href="#服务控制器" class="headerlink" title="服务控制器"></a>服务控制器</h4><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务（Service）</a>与受控的负载均衡器、 IP 地址、网络包过滤、目标健康检查等云基础设施组件集成。 服务控制器与云驱动的 API 交互，以配置负载均衡器和其他基础设施组件。 你所创建的 Service 资源会需要这些组件服务。</p>
<h3 id="kube-scheduler调度器"><a href="#kube-scheduler调度器" class="headerlink" title="kube-scheduler调度器"></a>kube-scheduler调度器</h3><p>kube-scheduler 是<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件，** 负责监视新创建的、未指定运行**<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/"><strong>节点（node）</strong></a>**的 **<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/"><strong>Pods</strong></a><strong>， 并选择节点来让 Pod 在上面运行。</strong><br>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。<br>主要作用简单来说就是通过一定的调度算法，将pod调度到更合适的节点上。</p>
<h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。<br>如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster">备份</a>计划。<br>你可以在官方<a target="_blank" rel="noopener" href="https://etcd.io/docs/">文档</a>中找到有关 etcd 的深入知识</p>
<h2 id="Node组件"><a href="#Node组件" class="headerlink" title="Node组件"></a>Node组件</h2><p><strong>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</strong><br>![image.png]&#x2F;images&#x2F;1711087487672-a29b5067-59e7-4dc9-93f7-a027e6921177.png)</p>
<blockquote>
<p>一台服务器是一个节点， 一个节点下面可能有多个Pod， 一个Pod下面可能会有多个容器</p>
</blockquote>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p><strong>kubelet 会在集群中每个</strong><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/"><strong>节点（node）</strong></a><strong>上运行。 它保证</strong><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers"><strong>容器（containers）</strong></a>**都运行在 <strong><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/"><strong>Pod</strong></a></strong> 中。（简单来说就是负责pod的生命周期、存储、网络）<br><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/"><strong>kubelet</strong></a> 接收一组通过各类机制提供给它的 PodSpec，确保这些 PodSpec 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/"><strong>kube-proxy</strong></a>是集群中每个**<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/"><strong>节点（node）</strong></a>**上所运行的网络代理， 实现 Kubernetes <strong><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/"><strong>服务（Service）</strong></a></strong> 概念的一部分。(简单来说就是负责Service的服务发现，负载均衡（4层负载）)<br>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。<br>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p>
<h3 id="容器运行时环境（Container-Runtime）"><a href="#容器运行时环境（Container-Runtime）" class="headerlink" title="容器运行时环境（Container Runtime）"></a>容器运行时环境（Container Runtime）</h3><blockquote>
<p>对应Java的运行时环境jre</p>
</blockquote>
<p><strong>这个基础组件使 Kubernetes 能够有效运行容器。 它负责管理 Kubernetes 环境中容器的执行和生命周期。</strong><br>Kubernetes 支持许多容器运行环境，例如 <a target="_blank" rel="noopener" href="https://containerd.io/docs/">containerd</a>（容器）、 <a target="_blank" rel="noopener" href="https://cri-o.io/#what-is-cri-o">CRI-O</a> （是 Kubernetes CRI（容器运行时接口）的实现，支持使用 OCI（开放容器计划）兼容的运行时。）以及 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">Kubernetes CRI (容器运行环境接口)</a> 的其他任何实现。</p>
<p>总共有很多， 这里简单介绍这几个。 剩下的后面在进行学习</p>
<h2 id="附加组件———插件（Addons）"><a href="#附加组件———插件（Addons）" class="headerlink" title="附加组件———插件（Addons）"></a>附加组件———插件（Addons）</h2><p>插件使用 Kubernetes 资源（<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>、 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a> 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。<br>下面描述众多插件中的几种。有关可用插件的完整列表，请参见 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/">插件（Addons）</a>。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/">集群 DNS</a>， 因为很多示例都需要 DNS 服务。<br>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。<br>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p>
<h3 id="Web-界面（仪表盘）"><a href="#Web-界面（仪表盘）" class="headerlink" title="Web 界面（仪表盘）"></a>Web 界面（仪表盘）</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/">Dashboard</a> 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身， 并进行故障排除。</p>
<h3 id="容器资源监控"><a href="#容器资源监控" class="headerlink" title="容器资源监控"></a>容器资源监控</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-usage-monitoring/">容器资源监控</a> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中， 并提供浏览这些数据的界面。</p>
<h3 id="集群层面日志"><a href="#集群层面日志" class="headerlink" title="集群层面日志"></a>集群层面日志</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/logging/">集群层面日志</a>机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口。</p>
<h3 id="网络插件"><a href="#网络插件" class="headerlink" title="网络插件"></a>网络插件</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins">网络插件</a> 是实现容器网络接口（CNI）规范的软件组件。它们负责为 Pod 分配 IP 地址，并使这些 Pod 能在集群内部相互通信。</p>
<h2 id="Kubernetes-API"><a href="#Kubernetes-API" class="headerlink" title="Kubernetes API"></a>Kubernetes API</h2><p>**Kubernetes **<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane"><strong>控制面</strong></a>**的核心是 **<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver"><strong>API 服务器</strong></a><strong>。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。</strong><br><strong>Kubernetes API 使你可以在 Kubernetes 中查询和操纵 API 对象 （例如 Pod、Namespace、ConfigMap 和 Event）的状态。</strong><br>大部分操作都可以通过 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/kubectl/">kubectl</a> 命令行接口或类似 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/">kubeadm</a> 这类命令行工具来执行， 这些工具在背后也是调用 API。不过，你也可以使用 REST 调用来访问这些 API。</p>
<p>每个 Kubernetes 集群都会发布集群所使用的 API 规范。 Kubernetes 使用两种机制来发布这些 API 规范；这两种机制都有助于实现自动互操作。 </p>
<ul>
<li>**发现（Discovery） API 提供有关 Kubernetes API 的信息：API 名称、资源、版本和支持的操作。 **此 API 是特定于 Kubernetes 的一个术语，因为它是一个独立于 Kubernetes OpenAPI 的 API。 其目的是为可用的资源提供简要总结，不详细说明资源的具体模式。有关资源模式的参考，请参阅 OpenAPI 文档。</li>
<li>**Kubernetes OpenAPI 文档为所有 Kubernetes API 端点提供（完整的） **<a target="_blank" rel="noopener" href="https://www.openapis.org/"><strong>OpenAPI v2.0 和 v3.0 模式</strong></a><strong>。</strong>OpenAPI v3 是访问 OpenAPI 的首选方法， 因为它提供了更全面和准确的 API 视图。其中包括所有可用的 API 路径，以及每个端点上每个操作所接收和生成的所有资源。 它还包括集群支持的所有可扩展组件。这些数据是完整的规范，比 Discovery API 提供的规范要大得多。</li>
</ul>
<h3 id="Discovery-API"><a href="#Discovery-API" class="headerlink" title="Discovery API"></a>Discovery API</h3><p>Kubernetes 通过 Discovery API 发布集群所支持的所有组版本和资源列表。对于每个资源，包括以下内容：</p>
<ul>
<li>名称</li>
<li>集群作用域还是名字空间作用域</li>
<li>端点 URL 和所支持的动词</li>
<li>别名</li>
<li>组、版本、类别</li>
</ul>
<h3 id="OpenAPI-接口定义"><a href="#OpenAPI-接口定义" class="headerlink" title="OpenAPI 接口定义"></a>OpenAPI 接口定义</h3><p>有关 OpenAPI 规范的细节，参阅 <a target="_blank" rel="noopener" href="https://www.openapis.org/">OpenAPI 文档</a>。<br>Kubernetes 同时提供 OpenAPI v2.0 和 OpenAPI v3.0。OpenAPI v3 是访问 OpenAPI 的首选方法， 因为它提供了对 Kubernetes 资源更全面（无损）的表示。由于 OpenAPI v2 的限制， 所公布的 OpenAPI 中会丢弃掉一些字段，包括但不限于 default、nullable、oneOf。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>**Kubernetes 通过将序列化状态的对象写入到 **<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/"><strong>etcd</strong></a>中完成存储操作。</p>
<h1 id="Kubernetes整体的架构"><a href="#Kubernetes整体的架构" class="headerlink" title="Kubernetes整体的架构"></a>Kubernetes整体的架构</h1><p><strong>上述中我们学习到的相关名词， 在这里都可以找到对应的标识</strong><br>![image.png]&#x2F;images&#x2F;1710747807342-7dd88056-06b2-490d-9c46-b108bfbb89d5.png)</p>
<blockquote>
<p>这张图片展示的是一个Kubernetes集群的架构图，这是一个用于自动化部署、扩展和管理容器化应用程序的系统。<br>图中上方的“CONTROL PLANE”是控制平面，它负责整个集群的管理和协调工作。控制平面的组件包括：</p>
<ul>
<li><strong>etcd</strong>：一个轻量级的分布式键值存储，用于保存所有集群数据，确保数据的一致性。</li>
<li><strong>kube-api-server</strong>：作为Kubernetes API的服务端，是控制平面的前端，与其他组件交互。</li>
<li><strong>scheduler</strong>（kube-scheduler）：负责调度决策，选择哪个节点运行未分配的Pod。</li>
<li><strong>Controller Manager</strong>（kube-controller-manager）：运行控制器进程，这些进程包括节点控制器、端点控制器、命名空间控制器等。</li>
<li><strong>cloud-control-manager</strong>：链接到各种云服务提供商的控制器，以便Kubernetes可以使用云提供商的特定资源。</li>
</ul>
<p>图中中间的“CLUSTER”是(cluster)集群本身，通常包含多个Node 节点，图中展示了两个节点。<br>每个节点包含：</p>
<ul>
<li><strong>kubelet</strong>：确保容器运行在Pod中。它接受来自kube-api-server的指令，管理Pod和容器运行。</li>
<li><strong>kube-proxy</strong>：维护节点网络规则，执行连接转发。</li>
</ul>
<p>节点内部还包括：</p>
<ul>
<li><strong>Pod</strong>：最小的部署单元，可以包含一个或多个容器。</li>
<li><strong>CRI</strong>：容器运行时接口，允许kubelet使用多种容器运行时。</li>
</ul>
<p>图中最右边的“CLOUD PROVIDER API”表示Kubernetes集群可以与云提供商的API进行交互，以利用云平台提供的资源和服务。<br>这个图清晰地展示了Kubernetes集群的不同组件以及它们之间的关系。控制平面负责集群的整体运行，而节点则是实际运行工作负载的地方。</p>
</blockquote>
<h2 id="K8S分层架构图"><a href="#K8S分层架构图" class="headerlink" title="K8S分层架构图"></a>K8S分层架构图</h2><p>![image.png]&#x2F;images&#x2F;1711088807653-6441d837-4ce5-44fc-8454-30b8b5f32e85.png)</p>
<ol>
<li><strong>Ecosystem生态系统层</strong></li>
</ol>
<p>最顶层是指 Kubernetes 的生态系统，包括所有与 Kubernetes 集成的额外工具和服务，比如 CI&#x2F;CD 工具、监控和日志工具、各种扩展和插件等。这些不是 Kubernetes 的必要部分，但它们丰富了 Kubernetes 的功能，使其能够更好地服务于不同的使用场景。</p>
<ol start="2">
<li><strong>Interface Layer接口层：客户端库和工具</strong></li>
</ol>
<p>这一层为开发者和管理员提供与 Kubernetes 集群交互的客户端库和命令行工具，如 kubectl 和 Kubernetes 的客户端 SDK。</p>
<ol start="3">
<li><strong>Governance Layer 治理层：自动化和策略执行</strong></li>
</ol>
<p>此层包含了自动化操作和策略执行的工具和组件，如自动扩缩容、Pod 生命周期管理、策略的定义和执行等。</p>
<ol start="4">
<li><strong>Appication Layer 应用层：部署和路由</strong></li>
</ol>
<p>位于核心层之上，负责应用的部署、服务发现和路由。这涉及到部署应用、更新和回滚、服务发现和负载均衡。</p>
<ol start="5">
<li><strong>Nucleus 核心层（ 也就是我们之前说的control plane 控制平面层的相关组件）</strong></li>
</ol>
<p><strong>这是 Kubernetes 架构的基础，包含了核心的 API 服务器和执行逻辑。</strong>这一层负责处理和响应 API 请求，以及维护集群的状态。这一层的组件包括：</p>
<ul>
<li><strong>Container Runtime</strong>：容器运行时，负责运行容器，如 Docker、containerd 等。</li>
<li><strong>Network Plugin</strong>：网络插件，管理 Pod 间和集群内部的网络通信，如 Calico、Flannel 等。</li>
<li><strong>Volume Plugin</strong>：存储卷插件，管理存储挂载和卷的生命周期。</li>
<li><strong>Image Registry</strong>：镜像仓库，用于存储容器镜像，如 Docker Hub、Google Container Registry。</li>
<li><strong>Cloud Provider</strong>：云服务提供者，与云平台集成，实现服务的自动化部署和扩缩容。</li>
<li><strong>Identity Provider</strong>：身份提供者，用于认证和授权。</li>
</ul>
<p>:::info<br>在 Kubernetes 的核心层，<strong>这些组件共同工作，提供了创建、调度、运行和管理容器化应用所需的所有功能。</strong>API Server 作为核心服务，其他组件都通过它与 Kubernetes 的控制平面进行通信，它负责接受和处理 REST 请求，操作 etcd（存储集群状态的键值数据库）来保存集群状态，以及调度工作到具体的节点上。核心层的设计是为了确保集群的稳定和高效运作，它处理的是更低级别、更接近系统的操作，为集群的其他部分提供服务。<br>:::</p>
<h2 id="节点Node"><a href="#节点Node" class="headerlink" title="节点Node"></a>节点Node</h2><p>Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/">工作负载</a>。** 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。** 每个节点包含运行 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 所需的服务； 这些节点由<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制面</a>负责管理。<br>通常集群中会有若干个节点；<strong>而在一个学习所用或者资源受限的环境中，你的集群中也可能只有一个节点。</strong><br>节点上的<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#node-components">组件</a>包括 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a>、 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes">容器运行时</a>以及 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a>。</p>
<h2 id="CRI（容器运行时接口）"><a href="#CRI（容器运行时接口）" class="headerlink" title="CRI（容器运行时接口）"></a>CRI（容器运行时接口）</h2><p>CRI 是一个插件接口，它使 kubelet 能够使用各种容器运行时，无需重新编译集群组件。<br>你需要在集群中的每个节点上都有一个可以正常工作的<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes">容器运行时</a>， 这样 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a> 能启动 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 及其容器。<br>容器运行时接口（CRI）是 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a> 和容器运行时之间通信的主要协议。<br>Kubernetes 容器运行时接口（Container Runtime Interface；CRI）<strong>定义了主要 <strong><a target="_blank" rel="noopener" href="https://grpc.io/"><strong>gRPC</strong></a> 协议， 用于</strong><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#node-components"><strong>节点组件</strong></a></strong> <strong><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubelet"><strong>kubelet</strong></a></strong> 和**<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes"><strong>容器运行时</strong></a>**之间的通信。</p>
<h2 id="节点与控制面之间的通信"><a href="#节点与控制面之间的通信" class="headerlink" title="节点与控制面之间的通信"></a>节点与控制面之间的通信</h2><p>本段列举控制面节点（确切地说是 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver">API 服务器</a>）和 Kubernetes <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-cluster">集群</a>之间的通信路径。 目的是为了让用户能够自定义他们的安装，以实现对网络配置的加固， 使得集群能够在不可信的网络上（或者在一个云服务商完全公开的 IP 上）运行。</p>
<h2 id="节点到控制面"><a href="#节点到控制面" class="headerlink" title="节点到控制面"></a>节点到控制面</h2><p>Kubernetes 采用的是中心辐射型（Hub-and-Spoke）API 模式。 所有从节点（或运行于其上的 Pod）发出的 API 调用都终止于 API 服务器。 其它控制面组件都没有被设计为可暴露远程服务。 API 服务器被配置为在一个安全的 HTTPS 端口（通常为 443）上监听远程连接请求， 并启用一种或多种形式的客户端<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/">身份认证</a>机制。 一种或多种客户端<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authorization/">鉴权机制</a>应该被启用， 特别是在允许使用<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/#anonymous-requests">匿名请求</a> 或<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/#service-account-tokens">服务账户令牌</a>的时候。<br>应该使用集群的公共根<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/tls/managing-tls-in-a-cluster/">证书</a>开通节点， 这样它们就能够基于有效的客户端凭据安全地连接 API 服务器。 一种好的方法是以客户端证书的形式将客户端凭据提供给 kubelet。 请查看 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/">kubelet TLS 启动引导</a> 以了解如何自动提供 kubelet 客户端证书。<br>想要连接到 API 服务器的 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 可以使用服务账号安全地进行连接。 当 Pod 被实例化时，Kubernetes 自动把公共根证书和一个有效的持有者令牌注入到 Pod 里。 kubernetes 服务（位于 default 名字空间中）配置了一个虚拟 IP 地址， 用于（通过 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a>）转发请求到 API 服务器的 HTTPS 末端。<br><strong>控制面组件也通过安全端口与集群的 API 服务器通信。</strong><br><strong>这样，从集群节点和节点上运行的 Pod 到控制面的连接的缺省操作模式即是安全的， 能够在不可信的网络或公网上运行。</strong></p>
<h4 id="控制面到节点"><a href="#控制面到节点" class="headerlink" title="控制面到节点"></a>控制面到节点</h4><p>从控制面（API 服务器）到节点有两种主要的通信路径。 第一种是从 API 服务器到集群中每个节点上运行的 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a> 进程。 第二种是从 API 服务器通过它的<strong>代理</strong>功能连接到任何节点、Pod 或者服务。</p>
<h2 id="…"><a href="#…" class="headerlink" title="…."></a>….</h2><h1 id="服务、负载均衡和联网"><a href="#服务、负载均衡和联网" class="headerlink" title="服务、负载均衡和联网"></a>服务、负载均衡和联网</h1><h2 id="Kubernetes-网络模型"><a href="#Kubernetes-网络模型" class="headerlink" title="Kubernetes 网络模型"></a>Kubernetes 网络模型</h2><p>**集群中每一个 **<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/"><strong>Pod</strong></a> 都会获得自己的、 独一无二的 IP 地址， <strong>这就意味着你不需要显式地在 Pod 之间创建链接，你</strong>几乎不需要处理容器端口到主机端口之间的映射。 这将形成一个干净的、向后兼容的模型；在这个模型里，从端口分配、命名、服务发现、 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#load-balancing">负载均衡</a>、 应用配置和迁移的角度来看，Pod 可以被视作虚拟机或者物理主机。</p>
<p>Kubernetes强制要求所有网络设施都满足以下基本要求（从而排除了有意隔离网络的策略）：</p>
<ul>
<li>Pod 能够与所有其他<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a>上的 Pod 通信， 且不需要网络地址转译（NAT）</li>
<li>节点上的代理（比如：系统守护进程、kubelet）可以和节点上的所有 Pod 通信</li>
</ul>
<p>说明：对于支持在主机网络中运行 Pod 的平台（比如：Linux）， 当 Pod 挂接到节点的宿主网络上时，它们仍可以不通过 NAT 和所有节点上的 Pod 通信。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Ray2310.github.io">Rayce.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ray2310.github.io/post/53db2c5f.html">https://ray2310.github.io/post/53db2c5f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Ray2310.github.io" target="_blank">Rayce. Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/kubernetes/">kubernetes</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/01/wallhaven-01jvd3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/9404648c.html" title="缓存穿透、雪崩、击穿三者如何解决"><img class="cover" src="https://w.wallhaven.cc/full/85/wallhaven-85rpvy.png" onerror="onerror=null;src='/img/second.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">缓存穿透、雪崩、击穿三者如何解决</div></div></a></div><div class="next-post pull-right"><a href="/post/81231d2a.html" title="自省"><img class="cover" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRAV5IsDhf40B0JNiTadUzM9WvxBWbE9ud8mw&amp;usqp=CAU" onerror="onerror=null;src='/img/second.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">自省</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/af89f2f5.html" title="容器化守护进程DaemonSet"><img class="cover" src="https://w.wallhaven.cc/full/gp/wallhaven-gp65y7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-25</div><div class="title">容器化守护进程DaemonSet</div></div></a></div><div><a href="/post/46fb6ae1.html" title="说说Headless Service"><img class="cover" src="https://w.wallhaven.cc/full/7p/wallhaven-7p75yy.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-20</div><div class="title">说说Headless Service</div></div></a></div><div><a href="/post/a5a12cb8.html" title="有状态应用的编排-statefulSet"><img class="cover" src="https://w.wallhaven.cc/full/l8/wallhaven-l8ppv2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-20</div><div class="title">有状态应用的编排-statefulSet</div></div></a></div><div><a href="/post/25bb90fa.html" title="Deployment容器编排？怎么编排"><img class="cover" src="https://w.wallhaven.cc/full/l8/wallhaven-l8xql2.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-16</div><div class="title">Deployment容器编排？怎么编排</div></div></a></div><div><a href="/post/72dd3c2b.html" title="Kubernetes的pod解析"><img class="cover" src="https://w.wallhaven.cc/full/p9/wallhaven-p913ep.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-15</div><div class="title">Kubernetes的pod解析</div></div></a></div><div><a href="/post/a6460819.html" title="Kubernetes安装总结"><img class="cover" src="https://w.wallhaven.cc/full/d6/wallhaven-d6jx53.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-13</div><div class="title">Kubernetes安装总结</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/109897266?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rayce.</div><div class="author-info__description">Time never speaks, but answers all questions</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ray2310"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ray2310" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1326507725@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p align="center">无人扶我青云志，我自踏雪至山巅</p> <p align="center">倘若命中无此运，孤身亦可登昆仑</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">基本概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%82%A3%E4%B9%88%E5%A5%BD%EF%BC%8C-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8k8s%EF%BC%9F"><span class="toc-number">1.0.1.</span> <span class="toc-text">容器那么好， 为什么还要用k8s？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Kubernetes%EF%BC%8C-%E5%AE%83%E8%83%BD%E5%A4%9F%E5%81%9A%E4%BB%80%E4%B9%88-%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">为什么需要Kubernetes， 它能够做什么 ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K8S%E8%83%BD%E5%A4%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.1.</span> <span class="toc-text">K8S能够提供的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K8s%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88-%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">K8s不是什么 ？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9CK8s-%E2%80%94-K8s%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">操作K8s —- K8s对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0-Kubernetes-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">描述 Kubernetes 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%85%E9%9C%80%E5%AD%97%E6%AE%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">必需字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">Pod是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">主要特性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">容器镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">容器运行时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#K8s%E7%BB%84%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">K8s组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6%EF%BC%88Control-Plame%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF%EF%BC%89%E2%80%94-%E5%9C%A8master%E4%B8%8A"><span class="toc-number">2.1.</span> <span class="toc-text">控制平面组件（Control Plame控制面板）—-在master上</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kube-apiserver"><span class="toc-number">2.1.1.</span> <span class="toc-text">kube-apiserver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kube-x2F-cloud-controller-manager"><span class="toc-number">2.1.2.</span> <span class="toc-text">kube&#x2F;cloud-controller-manager</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8C%85%E6%8B%AC%EF%BC%9A-%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">控制器包括： 节点控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">路由控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">服务控制器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kube-scheduler%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">kube-scheduler调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#etcd"><span class="toc-number">2.1.4.</span> <span class="toc-text">etcd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">Node组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kubelet"><span class="toc-number">2.2.1.</span> <span class="toc-text">kubelet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kube-proxy"><span class="toc-number">2.2.2.</span> <span class="toc-text">kube-proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%EF%BC%88Container-Runtime%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">容器运行时环境（Container Runtime）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94%E2%80%94%E6%8F%92%E4%BB%B6%EF%BC%88Addons%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">附加组件———插件（Addons）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS"><span class="toc-number">2.3.1.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E7%95%8C%E9%9D%A2%EF%BC%88%E4%BB%AA%E8%A1%A8%E7%9B%98%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">Web 界面（仪表盘）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7"><span class="toc-number">2.3.3.</span> <span class="toc-text">容器资源监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%B1%82%E9%9D%A2%E6%97%A5%E5%BF%97"><span class="toc-number">2.3.4.</span> <span class="toc-text">集群层面日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6"><span class="toc-number">2.3.5.</span> <span class="toc-text">网络插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes-API"><span class="toc-number">2.4.</span> <span class="toc-text">Kubernetes API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Discovery-API"><span class="toc-number">2.4.1.</span> <span class="toc-text">Discovery API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenAPI-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">OpenAPI 接口定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.5.</span> <span class="toc-text">持久化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes%E6%95%B4%E4%BD%93%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">Kubernetes整体的架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#K8S%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">K8S分层架构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9Node"><span class="toc-number">3.2.</span> <span class="toc-text">节点Node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CRI%EF%BC%88%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">CRI（容器运行时接口）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E4%B8%8E%E6%8E%A7%E5%88%B6%E9%9D%A2%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">3.4.</span> <span class="toc-text">节点与控制面之间的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%88%B0%E6%8E%A7%E5%88%B6%E9%9D%A2"><span class="toc-number">3.5.</span> <span class="toc-text">节点到控制面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E9%9D%A2%E5%88%B0%E8%8A%82%E7%82%B9"><span class="toc-number">3.5.0.1.</span> <span class="toc-text">控制面到节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%A6"><span class="toc-number">3.6.</span> <span class="toc-text">….</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E8%81%94%E7%BD%91"><span class="toc-number">4.</span> <span class="toc-text">服务、负载均衡和联网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">Kubernetes 网络模型</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/af89f2f5.html" title="容器化守护进程DaemonSet"><img src="https://w.wallhaven.cc/full/gp/wallhaven-gp65y7.jpg" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="容器化守护进程DaemonSet"/></a><div class="content"><a class="title" href="/post/af89f2f5.html" title="容器化守护进程DaemonSet">容器化守护进程DaemonSet</a><time datetime="2024-07-25T15:25:01.000Z" title="发表于 2024-07-25 23:25:01">2024-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/46fb6ae1.html" title="说说Headless Service"><img src="https://w.wallhaven.cc/full/7p/wallhaven-7p75yy.png" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="说说Headless Service"/></a><div class="content"><a class="title" href="/post/46fb6ae1.html" title="说说Headless Service">说说Headless Service</a><time datetime="2024-07-20T14:53:23.000Z" title="发表于 2024-07-20 22:53:23">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/a5a12cb8.html" title="有状态应用的编排-statefulSet"><img src="https://w.wallhaven.cc/full/l8/wallhaven-l8ppv2.jpg" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="有状态应用的编排-statefulSet"/></a><div class="content"><a class="title" href="/post/a5a12cb8.html" title="有状态应用的编排-statefulSet">有状态应用的编排-statefulSet</a><time datetime="2024-07-20T14:47:45.000Z" title="发表于 2024-07-20 22:47:45">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/25bb90fa.html" title="Deployment容器编排？怎么编排"><img src="https://w.wallhaven.cc/full/l8/wallhaven-l8xql2.png" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="Deployment容器编排？怎么编排"/></a><div class="content"><a class="title" href="/post/25bb90fa.html" title="Deployment容器编排？怎么编排">Deployment容器编排？怎么编排</a><time datetime="2024-07-16T15:55:47.000Z" title="发表于 2024-07-16 23:55:47">2024-07-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/72dd3c2b.html" title="Kubernetes的pod解析"><img src="https://w.wallhaven.cc/full/p9/wallhaven-p913ep.jpg" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="Kubernetes的pod解析"/></a><div class="content"><a class="title" href="/post/72dd3c2b.html" title="Kubernetes的pod解析">Kubernetes的pod解析</a><time datetime="2024-07-15T15:41:31.000Z" title="发表于 2024-07-15 23:41:31">2024-07-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://w.wallhaven.cc/full/01/wallhaven-01jvd3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Rayce.</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> <a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>