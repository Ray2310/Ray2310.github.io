<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Kubernetes的pod解析 | Rayce. Blogs</title><meta name="author" content="Rayce."><meta name="copyright" content="Rayce."><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="容器、镜像、Pod三者的关系  在正式学习pod这个概念之前， 我想先和读者共同学习一下容器、镜像、pod这几个我们在云原生环境中经常听到的名词的概述， 以及他们三者之间究竟有者怎么样的关联关系， 使得我们在云原生中常常用到。  镜像——部署项目的基石定义：容器镜像是一个只读的模板，包含了运行应用程序所需的所有代码、运行时库、环境变量和配置文件等。它是一个特殊的文件系统，用于提供容器运行时所需的程">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes的pod解析">
<meta property="og:url" content="https://ray2310.github.io/post/72dd3c2b.html">
<meta property="og:site_name" content="Rayce. Blogs">
<meta property="og:description" content="容器、镜像、Pod三者的关系  在正式学习pod这个概念之前， 我想先和读者共同学习一下容器、镜像、pod这几个我们在云原生环境中经常听到的名词的概述， 以及他们三者之间究竟有者怎么样的关联关系， 使得我们在云原生中常常用到。  镜像——部署项目的基石定义：容器镜像是一个只读的模板，包含了运行应用程序所需的所有代码、运行时库、环境变量和配置文件等。它是一个特殊的文件系统，用于提供容器运行时所需的程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/p9/wallhaven-p913ep.jpg">
<meta property="article:published_time" content="2024-07-15T15:41:31.000Z">
<meta property="article:modified_time" content="2024-07-15T15:45:02.981Z">
<meta property="article:author" content="Rayce.">
<meta property="article:tag" content="kubernetes">
<meta property="article:tag" content="云原生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/p9/wallhaven-p913ep.jpg"><link rel="shortcut icon" href="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQQHlJW3iX0eSx0YEsPnrToEC7iKW4m3TEgiQ&usqp=CAU"><link rel="canonical" href="https://ray2310.github.io/post/72dd3c2b.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Rayce.","link":"链接: ","source":"来源: Rayce. Blogs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes的pod解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-15 23:45:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/109897266?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">145</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/p9/wallhaven-p913ep.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Rayce. Blogs"><span class="site-name">Rayce. Blogs</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kubernetes的pod解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-15T15:41:31.000Z" title="发表于 2024-07-15 23:41:31">2024-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-15T15:45:02.981Z" title="更新于 2024-07-15 23:45:02">2024-07-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/kubernetes/">kubernetes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kubernetes的pod解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="容器、镜像、Pod三者的关系"><a href="#容器、镜像、Pod三者的关系" class="headerlink" title="容器、镜像、Pod三者的关系"></a>容器、镜像、Pod三者的关系</h1><blockquote>
<p> 在正式学习pod这个概念之前， 我想先和读者共同学习一下容器、镜像、pod这几个我们在云原生环境中经常听到的名词的概述， 以及他们三者之间究竟有者怎么样的关联关系， 使得我们在云原生中常常用到。</p>
</blockquote>
<h2 id="镜像——部署项目的基石"><a href="#镜像——部署项目的基石" class="headerlink" title="镜像——部署项目的基石"></a>镜像——部署项目的基石</h2><p><strong>定义</strong>：容器镜像是一个只读的模板，包含了运行应用程序所需的所有代码、运行时库、环境变量和配置文件等。它是一个特殊的文件系统，用于提供容器运行时所需的程序、库、资源、配置等文件，并包含了一些为运行时准备的一些配置参数<br><strong>作用：</strong><br>在制作镜像时 ， 常常用到的就是Docker技术 。制作成的镜像使得应用程序及其依赖项可以在不同的环境中进行部署和运行， 无需担心环境问题而导致的问题。<br>它是创建容器的起点，通过在镜像上添加一个可写层，容器可以在镜像的基础上进行变化，而不会影响到原始镜像 ， 其实对于相关的配置文件在现网中不是打包到镜像中的，而是通过环境变量的方式读取的， 这就是在可写层执行的一个实例。</p>
<h2 id="容器——应用运行的实例"><a href="#容器——应用运行的实例" class="headerlink" title="容器——应用运行的实例"></a>容器——应用运行的实例</h2><p><strong>定义</strong>：<br>容器是Docker的核心概念之一，是一个独立运行的应用程序及其所有运行时依赖项的轻量级、可执行单元。它与镜像几乎一模一样，区别在于容器的最上面那一层是可读可写的。<br><strong>作用</strong>：<br>容器利用操作系统内核的功能（命名空间和控制组cgroup技术实现的）来隔离进程，并控制进程可以访问的CPU、内存和磁盘的数量。它们小巧轻便、速度快且可移植，可以在桌面、传统IT还是云端运行。</p>
<blockquote>
<p>命名空间隔离了每个容器的进程、网络、用户和挂载点，确保容器之间相互隔离。而cgroup则负责限制容器可以使用的资源，如CPU、内存和存储等。</p>
</blockquote>
<h3 id="容器与虚拟机的对比"><a href="#容器与虚拟机的对比" class="headerlink" title="容器与虚拟机的对比"></a>容器与虚拟机的对比</h3><p>与传统虚拟机相比，Docker容器具有更轻量级和快速启动的特点。传统虚拟机是在宿主机上运行一个完整的操作系统，而容器则共享宿主机的操作系统内核。这使得容器的资源消耗更低，启动时间更快。同时，由于容器共享操作系统，容器的隔离性相对虚拟机略低，但仍然足以满足大多数应用场景的需求。<br><img src="/images/1720855061577-6be5586a-ea92-4b19-98be-6d00460a73e4.png"></p>
<blockquote>
<p>这是他们在应用架构上的对比</p>
</blockquote>
<h2 id="pod——资源调度的基本单位"><a href="#pod——资源调度的基本单位" class="headerlink" title="pod——资源调度的基本单位"></a>pod——资源调度的基本单位</h2><p>为什么我要讲pod和容器、镜像拿出来共同对比呢。<br>随着容器数量的增加， 手动管理容器变的越来越困难。 这是就引入了编排工具kubernetes和DockerSwarm等。 但是DockerSwarm并没有改变自身， 而是在Docker的基础上做改进， 同时在支持广度上也只支持Docker镜像， 所以导致逐渐被淘汰。<br>但是kubernetes则不同， 他能够兼容各种镜像， 同时还能够自动化容器的部署、伸缩和管理， 使得容器集群的管理变的更加高效。 在这基础上， pod应运而生， 他将一组或者一个容器一个单独的单位。 要么全都调度成功， 要么全部调度失败。 同时对于像Java和Tomcat这种相互依赖的东西， pod的调度更加有优势。 对于相同作用的应用服务，给予其“同生共死”的权限。<br>但是， pod又是如何管理容器的呢  ？ 如何将其作为一个整体来管理的？ 这些都是我们的疑惑。 下面简要说说。 具体深入学习后面我再整理输出。</p>
<h3 id="CRI-x2F-OCI-x2F-RunTime-容器运行时-x2F-Pod-之间的关系"><a href="#CRI-x2F-OCI-x2F-RunTime-容器运行时-x2F-Pod-之间的关系" class="headerlink" title="CRI&#x2F;OCI&#x2F;RunTime(容器运行时)&#x2F;Pod 之间的关系"></a>CRI&#x2F;OCI&#x2F;RunTime(容器运行时)&#x2F;Pod 之间的关系</h3><p>为什么要说CRI ? 他又是什么 ?<br><strong>为什么从 <code>CRI</code>讲起，因为 k8s 集群使用 <code>kubelet</code> 服务通过<code>CRI</code> 接口和对应的 <code>runtime(运行时)</code>交互，从而控制管理容器。</strong> </p>
<h4 id="CRI（Container-Runtime-Interface）"><a href="#CRI（Container-Runtime-Interface）" class="headerlink" title="CRI（Container Runtime Interface）"></a>CRI（Container Runtime Interface）</h4><p><strong>CRI是个接口是Kubernetes中用于定义容器运行时与Kubelet之间通信的规范</strong>。它使得Kubernetes能够使用各种容器运行时，而不仅限于其最初默认的Docker。</p>
<blockquote>
<p>借用山河无恙大哥的一张图</p>
</blockquote>
<p><img src="/images/1720856387780-5e704d96-a059-49ee-9509-79a23a856634.webp"><br>在 <code>K8s</code>  生态中通过  <code>CRI</code>  接口来对 容器运行时进行管理，从而实现对容器镜像的管理，具体一点，通过 <code>kubelet</code> 调用容器运行时的 <code>grpc</code> 接口。<br>面向接口编程，类比在刚学编程时， <code>Java</code> 中，操作数据库，使用  <code>JDBC API</code> 来连接不同的数据库实现 <code>CRUD</code>，这里具体的数据操作通过不同<code>数据库的驱动包</code>来实现。<code>CRI</code>可以单纯理解为<code>JDBC</code>  ,<strong>CRI 实现类比不同的</strong><code>数据库驱动包</code><br>CRI接口使用Protocol Buffer，<strong>基于gRPC</strong>，定义了容器和镜像的服务接口。它分为两个主要服务：ImageService和RuntimeService。ImageService负责从仓库拉取镜像、查看和移除镜像的功能。RuntimeService则负责Pod和容器的生命周期管理，以及与容器的交互（如exec&#x2F;attach&#x2F;port-forward).</p>
<h4 id="OCI（Open-Container-Initiative）——-开放标准组织"><a href="#OCI（Open-Container-Initiative）——-开放标准组织" class="headerlink" title="OCI（Open Container Initiative）—— 开放标准组织"></a>OCI（Open Container Initiative）—— 开放标准组织</h4><p>OCI定义了一套容器规范，包括容器的镜像格式、运行时规范等。</p>
<h4 id="lt-容器运行时-gt-Container-Runtime-组件"><a href="#lt-容器运行时-gt-Container-Runtime-组件" class="headerlink" title="&lt;容器运行时&gt;Container  Runtime 组件"></a>&lt;容器运行时&gt;Container  Runtime 组件</h4><p><strong>这个基础组件使 Kubernetes 能够有效运行容器。 它负责管理 Kubernetes 环境中容器的生命周期管理，包括创建、启动、停止和删除容器等操作。</strong><br>你可以允许集群为一个 Pod 选择其默认的容器运行时。如果你需要在集群中使用多个容器运行时， 你可以为一个 Pod 指定 RuntimeClass， 以确保 Kubernetes 会使用特定的容器运行时来运行这些容器。</p>
<blockquote>
<p>容器运行时可以有多种实现，例如Docker、containerd、CRI-O等。这些容器运行时实现了CRI接口，使得Kubernetes可以与它们兼容。</p>
</blockquote>
<h3 id="总结关系概述"><a href="#总结关系概述" class="headerlink" title="总结关系概述"></a>总结关系概述</h3><p>:::info</p>
<ul>
<li><strong>Kubernetes与CRI</strong>：Kubernetes通过CRI接口与容器运行时通信，管理Pod中容器的生命周期。</li>
<li><strong>CRI与Runtime</strong>：容器运行时实现CRI接口，使得Kubernetes可以与不同的容器运行时兼容。</li>
<li><strong>OCI与Runtime</strong>：容器运行时通常遵循OCI规范，确保不同容器技术之间的互操作性。</li>
<li><strong>Pod与Runtime</strong>：Pod中的容器由容器运行时管理，它们共享存储、网络和运行选项<br>:::</li>
</ul>
<h1 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h1><p>前面这些基础知识是我们学习kubernetes基本必须要掌握的内容。只有掌握了整体的大致架构， 才能在每个知识点的学习中对应上， 这样才能构建出自己的知识树。<br>回归正题， 通过前面的学习我们都知道pod是容器编排的最基本单位。 所以，想要学好kubernetes， pod的各种细节是一定要烂熟于心的。 下面我们就来一点点学习</p>
<h2 id="Pod-的生命周期"><a href="#Pod-的生命周期" class="headerlink" title="Pod 的生命周期"></a>Pod 的生命周期</h2><p>Pod 在其生命周期中<strong>只会被调度一次</strong>。 将 Pod 分配到特定节点的过程称为<strong>绑定</strong>，而选择使用哪个节点的过程称为<strong>调度</strong>。 一旦 Pod 被调度并绑定到某个节点，Kubernetes 会尝试在该节点上运行 Pod。 Pod 会在该节点上运行，直到 Pod 停止或者被终止； 如果 Kubernetes 无法在选定的节点上启动 Pod（例如，如果节点在 Pod 启动前崩溃）， 那么特定的 Pod 将永远不会启动。</p>
<h3 id="pod的创建"><a href="#pod的创建" class="headerlink" title="pod的创建"></a>pod的创建</h3><p>在上一章的学习中， 我将pod创建的大致细节介绍了下， 同时，如果读者细心的话， 还会发现这两张图。<br><img src="/images/1720837703683-9bb3e490-ba9e-4cdc-9fc3-42303aebff84.png"></p>
<p><img src="/images/1720837736340-2e95debf-1064-4019-b1da-b1a9254ad42e.png"><br>这是通过原生的pod的形式创建的两张图 ，通过这两张图的<code>STATUS</code>可以看到，刚开是创建的时候<code>STATUS的值为ContainerCreating</code> 然后创建成功之后 <code>STATUS的值为Running</code> , 这是我们能够通过命令查看到的。 具体的细节 ，下面我来详细解释下。<br>:::info </p>
<h2 id="pod-创建详细流程"><a href="#pod-创建详细流程" class="headerlink" title="pod 创建详细流程"></a>pod 创建详细流程</h2><blockquote>
<p>以创建nginx的pod为例</p>
</blockquote>
<ol>
<li>用户在编写完pod的yaml文件之后在命令行中输入<code>kubectl apply -f nginx.yaml</code><strong>向Kubernetes API Server  发起一个创建pod的请求</strong>。 </li>
<li>Kubernetes API Server 接收到创建 Pod 的请求后，<strong>会对请求进行验证(验证文件的合法性、格式、内容类型等等)和授权检查。验证成功之后。</strong>API Server 不会直接创建 Pod，而是<strong>将这个请求转化为一个内部表示</strong>，例如一个含有 Pod 创建信息的 etcd 记录。</li>
<li><strong>调度器（Scheduler）监视API Server并分配至合适的节点</strong>。 调度要考虑的事情有很多， 比如 资源需求（如 CPU 和内存）、节点的可用资源、节点标签、亲和性和反亲和性规则等。  </li>
<li>kubelet接收并创建Pod。在调度器选定好节点之后 ，该节点上的<strong>kubelet组件，会从API Server获取新的Pod配置。 然后按照OCI标准 ， 通过CRI接口调用容器运行时。来创建并启动容器</strong></li>
<li>如果Pod创建失败， kubelet可以启动容器，或者根据重启策略重新创建pod。  <strong>Kubelet 监控容器的运行状态</strong>，并将状态更新反馈给 API Server。  </li>
<li>服务发现和负载均衡。 如果pod暴露了服务，kubernetes的Service就会实现服务发现和负载均衡。 kubernetes会通过kube-proxy组件在每个节点上配置网络规则， 以实现Pod之间和Pod与外部之间的通信。</li>
</ol>
<p>:::<br><img src="/images/1720873290586-a007ae4b-6aa0-4664-a405-01c3fe51d52f.jpeg"></p>
<h3 id="Pod销毁"><a href="#Pod销毁" class="headerlink" title="Pod销毁"></a>Pod销毁</h3><p>:::info</p>
<h3 id="Pod销毁的流程"><a href="#Pod销毁的流程" class="headerlink" title="Pod销毁的流程"></a>Pod销毁的流程</h3><ol>
<li>用户发起删除请求<code>kubectl delete pod &lt;pod-name&gt;</code> 然后通过API Server处理删除请求</li>
<li>API Server 接收到删除 Pod 的请求，并将该请求<strong>写入 etcd</strong>。   **API Server 将 Pod 的状态更新为 <strong><code>**Terminating**</code><strong>，并在元数据</strong>Metadata</strong>中添加 **<code>**deletionTimestamp**</code>**。  **</li>
<li>控制器管理器（Controller Manager） 监听到Pod状态为<code>Terminating</code> 并且开始执行预定义的删除流程 。对于有状态服务（绑定了持久卷声明PersistentVolumeClaim（PVC）  ）， 控制器管理器会更新PVC 。</li>
<li>发送sigterm信号给容器，清理资源。 <strong>kubelet监听到元数据Metadata中标记的</strong><code>**deletionTimestamp**</code><strong>就会通知容器优雅的关闭</strong>。 容器有 30 秒的宽限期（grace period）来完成正在进行的工作并优雅退出。  </li>
<li>对于那些不想优雅退出的容器， kubelet会在宽限期结束时发送sigkill信号强制终止容器。 </li>
<li><strong>容器运行时</strong>（如 Docker 或 containerd）收到 SIGTERM 或 SIGKILL 信号后，<strong>停止并移除容器</strong>。  </li>
<li>清理资源， EmptyDir卷， CNI网络插件等等</li>
<li>最后从APIServer中删除pod， 也就是kubelet清理完成之后发送信号， API Server 最终删除etcd中关于pod的全部信息<br>:::</li>
</ol>
<p>上述的总结，我个人人为非常详细了， 通过对每一步的详细分析， 我们大致可以知道一个pod从创建到启动的全过程， 以及从运行中到删除完成。</p>
<h3 id="调度的基础"><a href="#调度的基础" class="headerlink" title="调度的基础"></a>调度的基础</h3><p>然后具体的每个容器之间是通过**API Server进行通信的， 请求是 基于 HTTP&#x2F;HTTPS 协议的 RESTful API  **<br>其他的比如说Scheduler和kubelet监听pod的状态也是通过http请求</p>
<ol>
<li>kubelet的监听机制</li>
</ol>
<blockquote>
<p>kubelet监听pod的机制是通过<strong>Watch机制。 Watch 是 Kubernetes API 的一种特性，它允许客户端（如 Kubelet）持续接收对象的更改通知。  **<br>Kubelet 会发起一个 Watch 请求，API Server 会保持这个连接，并在有相关对象的更改时立即返回更改内容。<br>Watch 请求是通过 HTTP&#x2F;HTTPS 协议进行的，通常使用</strong>长连接**（长时间保持连接<br>**API Server 返回的响应是一个持续的 JSON 流，每当有对象变化（如创建、更新或删除）时，都会在流中发送一个事件通知。  **</p>
</blockquote>
<ol start="2">
<li>Scheduler的监听机制</li>
</ol>
<blockquote>
<p><strong>Scheduler 监听 Pod 的机制是一种<br>Scheduler 也使用 List and Watch 模式从 API Server 获</strong>取未调度的 Pod 列表<strong>，</strong>并监听新创建的 Pod。  **<br>当有新的未调度的 Pod 被创建时，API Server 会将事件发送给 Scheduler。<br><strong>Scheduler 收到事件后，会根据调度策略为 Pod 选择一个合适的节点，并更新 Pod 的 <strong><code>**spec.nodeName**</code></strong> 字段，完成调度。</strong></p>
</blockquote>
<p><strong>为了确保数据传输的安全性，Kubernetes 使用 TLS&#x2F;SSL 加密 HTTP 通信，默认情况下，API Server 使用 HTTPS。</strong><br>API Server 的证书和密钥可以通过配置文件指定，通常保存在 <code>/etc/kubernetes/pki</code> 目录下。</p>
<p>:::info</p>
<h3 id="调度的关键点"><a href="#调度的关键点" class="headerlink" title="调度的关键点"></a>调度的关键点</h3><ul>
<li><strong>API Server 作为中心</strong>：所有组件的通信都通过 API Server 进行，API Server 是 Kubernetes 的中心枢纽。</li>
<li><strong>HTTP&#x2F;HTTPS 协议</strong>：所有通信都使用 HTTP&#x2F;HTTPS 协议，确保安全和标准化的通信。</li>
<li><strong>Watch 机制</strong>：Kubelet 和 Scheduler 通过 Watch 机制监听 Pod 的变化，实现实时更新<br>:::</li>
</ul>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="容器探针"><a href="#容器探针" class="headerlink" title="容器探针"></a>容器探针</h2><p><strong>容器探针（Container Probes）是一种机制，由 kubelet 对容器执行的定期诊断，从而获取容器的状态。</strong><br>分布式系统和微服务体系结构的挑战之一<strong>是自动检测不正常的应用程序（在云原生架构下就是pod）</strong>，并将请求（request）重新路由到其他可用系统，恢复损坏的组件。健康检查是应对该挑战的一种可靠方法。使用 Kubernetes，可以通过探针配置运行状况检查，以确定每个 Pod 的状态。<br>kubernetes中的探针类型总共有三种， 分别是liveness probe、readiness probe和startup 探针。每类探针都支持三种探测方法 。 下面我们来一一学习</p>
<h3 id="三种探针"><a href="#三种探针" class="headerlink" title="三种探针"></a>三种探针</h3><ol>
<li><strong>liveness Probe（存活探针）</strong>： 作用的是单个容器， 如果检查失败， 那么kubelet将杀死容器， 然后根据pod的restartPolicy来操作。</li>
</ol>
<p><strong>运行原理：</strong></p>
<blockquote>
<p>用于判断容器是否存活，即Pod是否为running状态，如果LivenessProbe探针探测到容器不健康，则kubelet将kill掉容器，并根据容器的重启策略是否重启。<br>如果一个容器不包含LivenessProbe探针，则Kubelet认为容器的LivenessProbe探针的返回值永远成功。<br>有时应用程序可能因为某些原因（后端服务故障等）导致暂时无法对外提供服务，但应用软件没有终止，导致K8S无法隔离有故障的pod，调用者可能会访问到有故障的pod，导致业务不稳定。<br>K8S提供livenessProbe来检测应用程序是否正常运行，并且对相应状况进行相应的补救措施。<br>注意，liveness探测失败并一定不会重启pod，pod是否会重启由你的restart policy 控制。</p>
</blockquote>
<ol start="2">
<li><strong>Readiness Probe（就绪探针）：</strong>用于检查容器是否以及准备好接收流量。 如果探针检测到应用程序不可用， kubernetes就会将流量路由到其他容器， 并且将不可用的容器从负载均衡池中删除</li>
</ol>
<p>**运行原理： **</p>
<blockquote>
<p>用于判断容器是否启动完成，即容器的Ready是否为True，可以接收请求，如果ReadinessProbe探测失败，则容器的Ready将为False，<strong>控制器将此Pod的Endpoint从对应的service的Endpoint列表中移除</strong>，<strong>从此不再将任何请求调度此Pod上，直到下次探测成功</strong>。<br>通过使用Readiness探针，Kubernetes能够等待应用程序完全启动，然后才允许服务将流量发送到新副本。</p>
</blockquote>
<p>关于** Readiness 探针有一点很重要，它会在容器的整个生命周期中运行（这里实际上是错的， 因为他是在容器创建之后 ，启动探针success 之后才运行的）**。这意味着 Readiness 探针不仅会在启动时运行，而且还会在 Pod 运行期间反复运行。这是为了处理应用程序暂时不可用的情况（比如加载大量数据、等待外部连接时）。在这种情况下，我们不一定要杀死应用程序，可以等待它恢复。Readiness 探针可用于检测这种情况，并在 Pod 再次通过 Readiness 检查后，将流量发送到这些 Pod。</p>
<ol start="3">
<li><strong>Startup probe（启动探针）</strong>：指示容器中的应用是否已经启动。如果提供了启动探针(startup probe)，在启动探针Success之前会禁用所有其他探针，直到它成功为止。如果启动探针失败，kubelet 将杀死容器，容器服从其重启策略进行重启。如果容器没有提供启动探针，则默认状态为成功Success。</li>
</ol>
<h3 id="探针检查的四种检查机制"><a href="#探针检查的四种检查机制" class="headerlink" title="探针检查的四种检查机制"></a>探针检查的四种检查机制</h3><p><code>**exec**</code><br>在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。<br><code>**grpc**</code><br>使用 <a target="_blank" rel="noopener" href="https://grpc.io/">gRPC</a> 执行一个远程过程调用。 目标应该实现 <a target="_blank" rel="noopener" href="https://grpc.io/grpc/core/md_doc_health-checking.html">gRPC 健康检查</a>。 如果响应的状态是 “SERVING”，则认为诊断成功。<br><code>**httpGet**</code><br>对容器的 IP 地址上指定端口和路径执行 HTTP <code>GET</code> 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。<br><code>**tcpSocket**</code><br>对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。</p>
<h3 id="什么时候适合使用这三种探针"><a href="#什么时候适合使用这三种探针" class="headerlink" title="什么时候适合使用这三种探针"></a>什么时候适合使用这三种探针</h3><ol>
<li><strong>对于存活探针</strong>， 如果容器中的进程能够在遇到问题、不健康的情况下自行崩溃， 则不一定需要存活探针， 因为kubelet会自行的 根据配置的restartPolicy自动执行修复操作<strong>。如果你希望容器在探测失败时被杀死并重新启动，那么请指定一个存活态探针， 并指定 <strong><code>**restartPolicy**</code></strong> 为 “</strong><code>**Always**</code><strong>“ 或 “</strong><code>**OnFailure**</code><strong>“。</strong></li>
<li>**对于就绪探针， **如果想要仅在探测成功之后才开始向pod发送流量请求， 那么请指定就绪探针。 因为就绪态探针的存在意味着 Pod 将在启动阶段不接收任何数据，并且只有在探针探测成功后才开始接收数据。</li>
</ol>
<blockquote>
<p>如果你的应用程序对后端服务有严格的依赖性，你可以同时实现存活态和就绪态探针。 当应用程序本身是健康的，存活态探针检测通过后，就绪态探针会额外检查每个所需的后端服务是否可用。 这可以帮助你避免将流量导向只能返回错误信息的 Pod。</p>
</blockquote>
<ol start="3">
<li><strong>对于启动探针， <strong>如果所包含的</strong>容器需要较长时间才能启动就绪的 Pod 而言，启动探针是有用的。</strong> 你不再需要配置一个较长的存活态探测时间间隔，只需要设置另一个独立的配置选定， 对启动期间的容器执行探测，从而允许使用远远超出存活态时间间隔所允许的时长。</li>
</ol>
<h3 id="这几种探针是由谁发起的？"><a href="#这几种探针是由谁发起的？" class="headerlink" title="这几种探针是由谁发起的？"></a>这几种探针是由谁发起的？</h3><p> 在 Kubernetes 中，探针（启动探针、就绪探针、存活探针）是由 Kubelet 组件发起和管理的。Kubelet 是 Kubernetes 集群中每个节点上的一个代理，负责管理节点上的 Pod 和容器的生命周期。  </p>
<h2 id="init-容器"><a href="#init-容器" class="headerlink" title="init 容器"></a>init 容器</h2><p>每个 Pod 中可以包含多个容器， 应用运行在这些容器里面，同时 <strong>Pod 也可以有一个或多个先于应用容器启动的 Init 容器。</strong><br>Init 容器与普通的容器非常像，除了如下两点：</p>
<ul>
<li>它们总是运行到完成。</li>
<li>每个都必须在下一个启动之前成功完成。</li>
</ul>
<p>如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。 然而，如果 Pod 对应的 <code>restartPolicy</code> 值为 “Never”，并且 Pod 的 Init 容器失败， 则 Kubernetes 会将整个 Pod 状态设置为失败。<br><strong>Init 容器在主应用容器启动之前运行并完成其任务。 与边车容器不同， Init 容器不会持续与主容器一起运行。</strong></p>
<h2 id="边车（sidecar）容器"><a href="#边车（sidecar）容器" class="headerlink" title="边车（sidecar）容器"></a>边车（sidecar）容器</h2><blockquote>
<p>这里还有很多细节</p>
</blockquote>
<p>边车容器是与<strong>主应用容器</strong>在同一个 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 中运行的辅助容器。** 这些容器通过提供额外的服务或功能（如日志记录、监控、安全性或数据同步）来增强或扩展主应用容器的功能<strong>， <strong>而无需直接修改主应用代码。</strong><br>通常，一个 Pod 中只有一个应用程序容器。 例如，如果你有一个需要本地 Web 服务器的 Web 应用程序， 则本地 Web 服务器以边车容器形式运行，而 Web 应用本身以应用容器形式运行。 当然这只是其中的一种案例 。下面让我们来大致的了解一下sidecar容器吧<br><strong>Sidecar容器， 用的最多的日志记录和监控</strong><br>在kubernetes集群时代 ，监控告警成了预警失败的重要举措， 但是该如何使用监控呢， 每个pod作为集群的基本单元， 按照之前的架构图可以知道， sidecar 容器与同一 pod 中的主应用程序容器一起运行，允许它们共享相同的生命周期并有效地通信。<br>一般一个pod里运行一个容器，那一个pod里运行两个容器的意义何在？一个容器是主容器，一个是副容器sidecar,比如nginx容器用来提供服务，另外一个容器使用工具来进行日志分析，</strong>两个容器挂载同一个数 据卷，日志分析容器读取数据卷即可分析日志。**<br>日志作为任一系统不可或缺的部分，在K8S 官方文档 中也介绍了多种的日志采集形式，总结起来主要有下述3种：<strong>原生方式、DaemonSet方式和Sidecar方式</strong>。 三种方式都有利有弊，没有哪种方式能够完美的解决100%问题的，所以要根据场景来贴合。<strong>其中Sidecar方式为每个POD单独部署日志agent，相对资源占用较多，但灵活性以及多租户隔离性较强，建议大型的K8S集群或作为PAAS平台为多个业务方服务的集群使用该方式。</strong></p>
<blockquote>
<p>这里提供一个案例， 使用的openKruise 社区的FileBeat， 整体架构图如下<br><img src="/images/1721053573948-a9256fc8-dbd3-42e9-b93b-5d5c2df7c1f9.png" alt="image.png"></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">log</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">filebeat</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/beats/filebeat:7.16.2</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="推荐使用SidecarSet管理"><a href="#推荐使用SidecarSet管理" class="headerlink" title="推荐使用SidecarSet管理"></a>推荐使用SidecarSet管理</h3><p><strong>Pod Sidecar模式：</strong>通过在Pod里定义专门容器，来执行主业务容器需要的辅助工作（比如：日志采集容器，流量代理容器）。优势：将辅助能力同业务容器解耦，实现独立发布和能力重用。<strong>但是也有一些弊端，如下：</strong></p>
<ul>
<li><strong>业务Pod耦合（运维、代理）多种sidecar容器，增加配置的复杂性以及业务开发人员的学习成本</strong></li>
<li><strong>Sidecar容器升级将导致业务Pod重建，由于Sidecar容器一般是独立的中间件团队负责，如果升级会存在极大的业务方阻力</strong></li>
</ul>
<blockquote>
<p> 上面介绍的就是直接通过pod Sidecar来模式来管理日志</p>
</blockquote>
<h3 id="SidecarSet管理sidecar容器的利器"><a href="#SidecarSet管理sidecar容器的利器" class="headerlink" title="SidecarSet管理sidecar容器的利器"></a>SidecarSet管理sidecar容器的利器</h3><p><strong>SidecarSet是OpenKruise中针对sidecar容器管理抽象出来的概念</strong>，负责注入和升级k8s集群中的sidecar容器，是OpenKruise的核心workload之一，详细可参考：<a target="_blank" rel="noopener" href="https://openkruise.io/zh/docs/user-manuals/sidecarset/">SidecarSet文档</a>。</p>
<ul>
<li><strong>自动注入Sidecar：将sidecar容器配置与业务Workload（Deployment、CloneSet等）配置解耦，简化用户使用成本</strong></li>
<li><strong>独立升级Sidecar容器：不重建Pod，单独升级Sidecar容器，对业务无感</strong></li>
</ul>
<blockquote>
<p>我这里只能列出好处 ，但是自己目前也没有完善具体的用法和实现效果。….</p>
</blockquote>
<h2 id="临时容器"><a href="#临时容器" class="headerlink" title="临时容器"></a>临时容器</h2><p>临时容器：一种特殊的容器，该容器在现有 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 中临时运行，以便完成用户发起的操作，<strong>例如故障排查。 <strong>你</strong>会使用临时容器来检查服务</strong>，而不是用它来构建应用程序。<br>具体的用法： </p>
<ul>
<li>当由于容器崩溃或容器镜像不包含调试工具而导致 <code>kubectl exec</code> 无用时， 临时容器对于交互式故障排查很有用。</li>
</ul>
<h2 id="Pod-QoS-类"><a href="#Pod-QoS-类" class="headerlink" title="Pod QoS 类"></a>Pod QoS 类</h2><p>Kubernetes 中的 Pod Quality of Service (QoS) 类是一种用于描述 Pod 的资源分配优先级的机制</p>
<p>Kubernetes 提供了三种 QoS 类：</p>
<ol>
<li><strong>BestEffort（尽力而为）</strong>：这是最低的 QoS 类。BestEffort 类的 Pod 不保证任何资源分配。当集群资源紧张时，这些 Pod 将首先被驱逐以满足更高 QoS 类的 Pod 的需求。BestEffort 类的 Pod 仅在资源充足时才能运行。</li>
<li><strong>Burstable（突发）</strong>：这是中间的 QoS 类。Burstable 类的 Pod 在资源充足时可以运行，但在资源紧张时可能会受到限制。这些 Pod 保证了一定的最小资源分配（如 CPU 请求），但在必要时可以超过这个限制。当集群资源紧张时，Kubernetes 会根据驱逐策略来决定哪些 Burstable 类的 Pod 应该被驱逐。</li>
<li><strong>Guaranteed（保证）</strong>：这是最的 QoS 类。Guaranteed 类的 Pod 保证有充足的资源分配。这些 Pod 必须具有明确的 CPU 和内存请求和限制。当集群资源紧张时，Kubernetes 会优先驱逐低 QoS 类的 Pod，以确保 Guaranteed 类的 Pod 能够正常运行</li>
</ol>
<p><strong>可以通过kubernetes的describe来查看pod的Qos类</strong><br><img src="/images/1721054468058-36fdfb37-9fc2-4293-908e-02410ea7df6d.png" alt="image.png"></p>
<blockquote>
<p>BestEffort( 尽力而为 )</p>
</blockquote>
<h2 id="用户命名空间"><a href="#用户命名空间" class="headerlink" title="用户命名空间"></a>用户命名空间</h2><p>对于容器， 我们知道他是通过namespace和 cgroups实现隔离的。 但是在kubernetes中， 是按照pod来作为最小的单元划分的 。所以pod如何使用容器的</p>
<h2 id="DownwardAPI"><a href="#DownwardAPI" class="headerlink" title="DownwardAPI"></a>DownwardAPI</h2><p>对于容器来说，在不与 Kubernetes 过度耦合的情况下，拥有关于自身的信息有时是很有用的。 <strong>Downward API</strong> 允许容器在不使用 Kubernetes 客户端或 API 服务器的情况下<strong>获得自己或集群的信息【</strong>允许将集群中 Pod 的元数据（如 Pod 名称、命名空间、节点名称等）暴露给 Pod 内的容器】</p>
<blockquote>
<p>注意， 这些信息必须是容器启动之前就能确定下来的</p>
</blockquote>
<h1 id="工作负载——管理pod的抽象概念"><a href="#工作负载——管理pod的抽象概念" class="headerlink" title="工作负载——管理pod的抽象概念"></a>工作负载——管理pod的抽象概念</h1><p>在Kubernetes中，工作负载是对一组Pod的抽象模型，用于描述业务的运行载体。这些工作负载类型帮助用户定义和管理他们的应用程序，确保它们在容器化环境中高效运行。<br>工作负载是在Kubernetes上运行的应用程序，无论是由单个组件还是由多个一同工作的组件构成，都可以在一组Pod中运行。Kubernetes提供了多种内置的工作负载资源，如Deployment、StatefulSet、DaemonSet、Job和CronJob等，以简化应用程序的部署和管理。</p>
<p>接下来，以 Deployment 为例，我和你简单描述一下它对控制器模型的实现：</p>
<ol>
<li>Deployment <strong>控制器从 Etcd 中获取到所有携带了“app: nginx”标签的 Pod，</strong>然后<strong>统计它们的数量，这就是实际状态；</strong></li>
<li>Deployment 对象的 <strong>Replicas 字段的值就是期望状态；</strong></li>
<li>Deployment 控制器将两个状态做<strong>比较</strong>，然后根据比较结果，确定是创建 Pod，还是删除已有的 Pod（具体如何操作 Pod 对象，我会在下一篇文章详细介绍）。</li>
</ol>
<p>可以看到，一个 Kubernetes 对象的主要编排逻辑，实际上是在第三步的“对比”阶段完成的。<br><strong>这个操作，通常被叫作调谐（Reconcile）。这个调谐的过程，则被称作“Reconcile Loop”（调谐循环）或者“Sync Loop”（同步循环）。</strong><br>Kubernetes 项目“面向 API 对象编程”的一个直观体现。 使用一个对象控制管理另一个对象。<br><img src="/images/1721057497138-301ffe63-1104-4a27-a79d-2d5777dc8803.png" alt="image.png"><br>如上图所示，<strong>类似 Deployment 这样的一个控制器，实际上都是由上半部分的控制器定义（包括期望状态)，加上下半部分的被控制对象的模板组成的。</strong></p>
<p>对于更多更详细的控制器内容， 我们后面再进行讨论。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Ray2310.github.io">Rayce.</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ray2310.github.io/post/72dd3c2b.html">https://ray2310.github.io/post/72dd3c2b.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Ray2310.github.io" target="_blank">Rayce. Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kubernetes/">kubernetes</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/p9/wallhaven-p913ep.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/a6460819.html" title="Kubernetes安装总结"><img class="cover" src="https://w.wallhaven.cc/full/d6/wallhaven-d6jx53.jpg" onerror="onerror=null;src='/img/second.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kubernetes安装总结</div></div></a></div><div class="next-post pull-right"><a href="/post/25bb90fa.html" title="Deployment容器编排？怎么编排"><img class="cover" src="https://w.wallhaven.cc/full/l8/wallhaven-l8xql2.png" onerror="onerror=null;src='/img/second.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Deployment容器编排？怎么编排</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/828c8ae3.html" title="深入解析容器网络"><img class="cover" src="https://w.wallhaven.cc/full/x6/wallhaven-x6gvez.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-08-04</div><div class="title">深入解析容器网络</div></div></a></div><div><a href="/post/a723b8b0.html" title="浅谈Kubernetes的存储"><img class="cover" src="https://w.wallhaven.cc/full/4x/wallhaven-4xg1qv.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-30</div><div class="title">浅谈Kubernetes的存储</div></div></a></div><div><a href="/post/39c7ed83.html" title="声明式Api及其实际应用"><img class="cover" src="https://w.wallhaven.cc/full/l8/wallhaven-l8ppv2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-27</div><div class="title">声明式Api及其实际应用</div></div></a></div><div><a href="/post/af89f2f5.html" title="容器化守护进程DaemonSet"><img class="cover" src="https://w.wallhaven.cc/full/gp/wallhaven-gp65y7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-25</div><div class="title">容器化守护进程DaemonSet</div></div></a></div><div><a href="/post/46fb6ae1.html" title="说说Headless Service"><img class="cover" src="https://w.wallhaven.cc/full/7p/wallhaven-7p75yy.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-20</div><div class="title">说说Headless Service</div></div></a></div><div><a href="/post/a5a12cb8.html" title="有状态应用的编排-statefulSet"><img class="cover" src="https://w.wallhaven.cc/full/l8/wallhaven-l8ppv2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-20</div><div class="title">有状态应用的编排-statefulSet</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/109897266?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rayce.</div><div class="author-info__description">Time never speaks, but answers all questions</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">145</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ray2310"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ray2310" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1326507725@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p align="center">无人扶我青云志，我自踏雪至山巅</p> <p align="center">倘若命中无此运，孤身亦可登昆仑</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E3%80%81%E9%95%9C%E5%83%8F%E3%80%81Pod%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">容器、镜像、Pod三者的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E2%80%94%E2%80%94%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">1.1.</span> <span class="toc-text">镜像——部署项目的基石</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.</span> <span class="toc-text">容器——应用运行的实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.1.</span> <span class="toc-text">容器与虚拟机的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pod%E2%80%94%E2%80%94%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-number">1.3.</span> <span class="toc-text">pod——资源调度的基本单位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CRI-x2F-OCI-x2F-RunTime-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-x2F-Pod-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">CRI&#x2F;OCI&#x2F;RunTime(容器运行时)&#x2F;Pod 之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CRI%EF%BC%88Container-Runtime-Interface%EF%BC%89"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">CRI（Container Runtime Interface）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OCI%EF%BC%88Open-Container-Initiative%EF%BC%89%E2%80%94%E2%80%94-%E5%BC%80%E6%94%BE%E6%A0%87%E5%87%86%E7%BB%84%E7%BB%87"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">OCI（Open Container Initiative）—— 开放标准组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-gt-Container-Runtime-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">&lt;容器运行时&gt;Container  Runtime 组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%85%B3%E7%B3%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">总结关系概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pod"><span class="toc-number">2.</span> <span class="toc-text">Pod</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.</span> <span class="toc-text">Pod 的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pod%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">pod的创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pod-%E5%88%9B%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">pod 创建详细流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E9%94%80%E6%AF%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">Pod销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E9%94%80%E6%AF%81%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">Pod销毁的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-number">2.2.3.</span> <span class="toc-text">调度的基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">2.2.4.</span> <span class="toc-text">调度的关键点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.5.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%8E%A2%E9%92%88"><span class="toc-number">2.3.</span> <span class="toc-text">容器探针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%8E%A2%E9%92%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">三种探针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A2%E9%92%88%E6%A3%80%E6%9F%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">探针检查的四种检查机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%89%E7%A7%8D%E6%8E%A2%E9%92%88"><span class="toc-number">2.3.3.</span> <span class="toc-text">什么时候适合使用这三种探针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E5%87%A0%E7%A7%8D%E6%8E%A2%E9%92%88%E6%98%AF%E7%94%B1%E8%B0%81%E5%8F%91%E8%B5%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">2.3.4.</span> <span class="toc-text">这几种探针是由谁发起的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">init 容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E8%BD%A6%EF%BC%88sidecar%EF%BC%89%E5%AE%B9%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">边车（sidecar）容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8SidecarSet%E7%AE%A1%E7%90%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">推荐使用SidecarSet管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SidecarSet%E7%AE%A1%E7%90%86sidecar%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%A9%E5%99%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">SidecarSet管理sidecar容器的利器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AE%B9%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text">临时容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-QoS-%E7%B1%BB"><span class="toc-number">2.7.</span> <span class="toc-text">Pod QoS 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">2.8.</span> <span class="toc-text">用户命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DownwardAPI"><span class="toc-number">2.9.</span> <span class="toc-text">DownwardAPI</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86pod%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">工作负载——管理pod的抽象概念</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/828c8ae3.html" title="深入解析容器网络"><img src="https://w.wallhaven.cc/full/x6/wallhaven-x6gvez.png" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="深入解析容器网络"/></a><div class="content"><a class="title" href="/post/828c8ae3.html" title="深入解析容器网络">深入解析容器网络</a><time datetime="2024-08-04T03:49:58.000Z" title="发表于 2024-08-04 11:49:58">2024-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/a723b8b0.html" title="浅谈Kubernetes的存储"><img src="https://w.wallhaven.cc/full/4x/wallhaven-4xg1qv.jpg" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="浅谈Kubernetes的存储"/></a><div class="content"><a class="title" href="/post/a723b8b0.html" title="浅谈Kubernetes的存储">浅谈Kubernetes的存储</a><time datetime="2024-07-30T15:30:34.000Z" title="发表于 2024-07-30 23:30:34">2024-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/39c7ed83.html" title="声明式Api及其实际应用"><img src="https://w.wallhaven.cc/full/l8/wallhaven-l8ppv2.jpg" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="声明式Api及其实际应用"/></a><div class="content"><a class="title" href="/post/39c7ed83.html" title="声明式Api及其实际应用">声明式Api及其实际应用</a><time datetime="2024-07-27T13:30:43.000Z" title="发表于 2024-07-27 21:30:43">2024-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/af89f2f5.html" title="容器化守护进程DaemonSet"><img src="https://w.wallhaven.cc/full/gp/wallhaven-gp65y7.jpg" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="容器化守护进程DaemonSet"/></a><div class="content"><a class="title" href="/post/af89f2f5.html" title="容器化守护进程DaemonSet">容器化守护进程DaemonSet</a><time datetime="2024-07-25T15:25:01.000Z" title="发表于 2024-07-25 23:25:01">2024-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/46fb6ae1.html" title="说说Headless Service"><img src="https://w.wallhaven.cc/full/7p/wallhaven-7p75yy.png" onerror="this.onerror=null;this.src='/img/second.jpg'" alt="说说Headless Service"/></a><div class="content"><a class="title" href="/post/46fb6ae1.html" title="说说Headless Service">说说Headless Service</a><time datetime="2024-07-20T14:53:23.000Z" title="发表于 2024-07-20 22:53:23">2024-07-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://w.wallhaven.cc/full/p9/wallhaven-p913ep.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Rayce.</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> <a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>